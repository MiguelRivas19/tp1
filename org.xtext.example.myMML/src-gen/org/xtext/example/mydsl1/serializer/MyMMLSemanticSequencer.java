/*
 * generated by Xtext 2.19.0
 */
package org.xtext.example.mydsl1.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.xtext.example.mydsl1.myMML.AlgorithmSet;
import org.xtext.example.mydsl1.myMML.CibleColumn;
import org.xtext.example.mydsl1.myMML.FileSet;
import org.xtext.example.mydsl1.myMML.MMLGenerator;
import org.xtext.example.mydsl1.myMML.MyMMLPackage;
import org.xtext.example.mydsl1.myMML.PredictiveColumns;
import org.xtext.example.mydsl1.myMML.PutIn;
import org.xtext.example.mydsl1.myMML.TestValueSize;
import org.xtext.example.mydsl1.myMML.TrainValueSize;
import org.xtext.example.mydsl1.services.MyMMLGrammarAccess;

@SuppressWarnings("all")
public class MyMMLSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private MyMMLGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == MyMMLPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case MyMMLPackage.ALGORITHM_SET:
				sequence_AlgorithmSet(context, (AlgorithmSet) semanticObject); 
				return; 
			case MyMMLPackage.CIBLE_COLUMN:
				sequence_CibleColumn(context, (CibleColumn) semanticObject); 
				return; 
			case MyMMLPackage.FILE_SET:
				sequence_FileSet(context, (FileSet) semanticObject); 
				return; 
			case MyMMLPackage.MML_GENERATOR:
				sequence_MMLGenerator(context, (MMLGenerator) semanticObject); 
				return; 
			case MyMMLPackage.PREDICTIVE_COLUMNS:
				sequence_PredictiveColumns(context, (PredictiveColumns) semanticObject); 
				return; 
			case MyMMLPackage.PUT_IN:
				sequence_PutIn(context, (PutIn) semanticObject); 
				return; 
			case MyMMLPackage.TEST_VALUE_SIZE:
				sequence_TestValueSize(context, (TestValueSize) semanticObject); 
				return; 
			case MyMMLPackage.TRAIN_VALUE_SIZE:
				sequence_TrainValueSize(context, (TrainValueSize) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     Element returns AlgorithmSet
	 *     AlgorithmSet returns AlgorithmSet
	 *
	 * Constraint:
	 *     algoName=Algo
	 */
	protected void sequence_AlgorithmSet(ISerializationContext context, AlgorithmSet semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyMMLPackage.Literals.ALGORITHM_SET__ALGO_NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyMMLPackage.Literals.ALGORITHM_SET__ALGO_NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAlgorithmSetAccess().getAlgoNameAlgoEnumRuleCall_2_0(), semanticObject.getAlgoName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Element returns CibleColumn
	 *     CibleColumn returns CibleColumn
	 *
	 * Constraint:
	 *     column=STRING
	 */
	protected void sequence_CibleColumn(ISerializationContext context, CibleColumn semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyMMLPackage.Literals.CIBLE_COLUMN__COLUMN) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyMMLPackage.Literals.CIBLE_COLUMN__COLUMN));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCibleColumnAccess().getColumnSTRINGTerminalRuleCall_2_0(), semanticObject.getColumn());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Element returns FileSet
	 *     FileSet returns FileSet
	 *
	 * Constraint:
	 *     text=STRING
	 */
	protected void sequence_FileSet(ISerializationContext context, FileSet semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyMMLPackage.Literals.FILE_SET__TEXT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyMMLPackage.Literals.FILE_SET__TEXT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFileSetAccess().getTextSTRINGTerminalRuleCall_2_0(), semanticObject.getText());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     MMLGenerator returns MMLGenerator
	 *
	 * Constraint:
	 *     instructions+=Instruction+
	 */
	protected void sequence_MMLGenerator(ISerializationContext context, MMLGenerator semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Element returns PredictiveColumns
	 *     PredictiveColumns returns PredictiveColumns
	 *
	 * Constraint:
	 *     column=STRING
	 */
	protected void sequence_PredictiveColumns(ISerializationContext context, PredictiveColumns semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyMMLPackage.Literals.PREDICTIVE_COLUMNS__COLUMN) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyMMLPackage.Literals.PREDICTIVE_COLUMNS__COLUMN));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPredictiveColumnsAccess().getColumnSTRINGTerminalRuleCall_2_0(), semanticObject.getColumn());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Instruction returns PutIn
	 *     PutIn returns PutIn
	 *
	 * Constraint:
	 *     (putId=ID value=Element)
	 */
	protected void sequence_PutIn(ISerializationContext context, PutIn semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyMMLPackage.Literals.PUT_IN__PUT_ID) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyMMLPackage.Literals.PUT_IN__PUT_ID));
			if (transientValues.isValueTransient(semanticObject, MyMMLPackage.Literals.PUT_IN__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyMMLPackage.Literals.PUT_IN__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPutInAccess().getPutIdIDTerminalRuleCall_1_0(), semanticObject.getPutId());
		feeder.accept(grammarAccess.getPutInAccess().getValueElementParserRuleCall_2_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Element returns TestValueSize
	 *     TestValueSize returns TestValueSize
	 *
	 * Constraint:
	 *     size=INT
	 */
	protected void sequence_TestValueSize(ISerializationContext context, TestValueSize semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyMMLPackage.Literals.TEST_VALUE_SIZE__SIZE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyMMLPackage.Literals.TEST_VALUE_SIZE__SIZE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTestValueSizeAccess().getSizeINTTerminalRuleCall_2_0(), semanticObject.getSize());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Element returns TrainValueSize
	 *     TrainValueSize returns TrainValueSize
	 *
	 * Constraint:
	 *     size=INT
	 */
	protected void sequence_TrainValueSize(ISerializationContext context, TrainValueSize semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyMMLPackage.Literals.TRAIN_VALUE_SIZE__SIZE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyMMLPackage.Literals.TRAIN_VALUE_SIZE__SIZE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTrainValueSizeAccess().getSizeINTTerminalRuleCall_2_0(), semanticObject.getSize());
		feeder.finish();
	}
	
	
}
